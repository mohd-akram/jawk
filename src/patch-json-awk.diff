--- src/JSON.awk.orig	2020-08-21 17:12:14.000000000 +0400
+++ src/JSON.awk	2020-08-21 17:22:51.000000000 +0400
@@ -19,7 +19,7 @@
 #   STREAM=: 0 or 1 {1}:
 #      zero hooks callbacks into parser and stdout printing.
 #   STRICT=: 0,1,2 {0}:
-#      1 enforce RFC8259#7 character escapes except for solidus '/'
+#      1 enforce RFC8259#7 character escapes except for solidus /
 #      2 enforce solidus escape too (for JSON embedded in HTML/XML)
 
 BEGIN { #{{{1
@@ -58,7 +58,7 @@
 	} # else usage: awk -f JSON.awk file1 [file2...]
 
 	# set file slurping mode
-	srand(); RS="\1n/o/m/a/t/c/h" rand()
+	srand(); RS="\1" rand()
 }
 
 { # main loop: process each file in turn {{{1
@@ -66,9 +66,11 @@
 
 	++FILEINDEX # 1-based
 	tokenize($0) # while(get_token()) {print TOKEN}
-	if (0 == parse() && 0 == STREAM) {
-		# Pass the callback an array of jpaths.
-		cb_jpaths(JPATHS, NJPATHS)
+	while (0 == parse()) {
+		if (0 == STREAM)
+			cb_jpaths(JPATHS, NJPATHS)
+		else
+			print ""
 	}
 }
 
@@ -130,7 +132,7 @@
 	}
 }
 
-function parse_array(a1,   idx,ary,ret) { #{{{1
+function parse_array(a1,   idx,ary,jpath,ret,x) { #{{{1
 	idx=0
 	ary=""
 	get_token()
@@ -159,6 +161,17 @@
 	} else {
 		VALUE = CB_VALUE = parse_array_empty(a1)
 	}
+
+	jpath = append_jpath_component(a1, "\"length\"")
+	x = append_jpath_value(jpath, idx)
+	if(0 == STREAM) {
+		# save jpath+value for cb_jpaths
+		JPATHS[++NJPATHS] = x
+	} else {
+		# consume jpath+value directly
+		print x
+	}
+
 	return 0
 }
 
@@ -181,7 +194,7 @@
 	}
 }
 
-function parse_object(a1,   key,obj) { #{{{1
+function parse_object(a1,   key,obj,keys,key_,jpath,x) { #{{{1
 	obj=""
 	get_token()
 #	print "parse_object(" a1 ") TOKEN=" TOKEN >"/dev/stderr"
@@ -202,6 +215,9 @@
 			if (parse_value(a1, key)) {
 				return 5
 			}
+			key_ = key
+			gsub(/^"|"$/, "", key_)
+			keys=(keys ? keys "\037" : "") key_
 			obj=obj key ":" VALUE
 			get_token()
 			if (TOKEN == "}") {
@@ -220,6 +236,15 @@
 	} else {
 		VALUE = CB_VALUE = parse_object_empty(a1)
 	}
+	jpath = append_jpath_component(a1, KEYS)
+	x = append_jpath_value(jpath, keys)
+	if(0 == STREAM) {
+		# save jpath+value for cb_jpaths
+		JPATHS[++NJPATHS] = x
+	} else {
+		# consume jpath+value directly
+		print x
+	}
 	return 0
 }
 
@@ -279,14 +304,10 @@
 
 function parse(   ret) { #{{{1
 	get_token()
+	if (!TOKEN) return 1;
 	if (ret = parse_value()) {
 		return ret
 	}
-	if (get_token() || "" != TOKEN) {
-		report("EOF", TOKEN)
-		return 10
-		# TODO the next JSON text starts here.
-	}
 	return 0
 }
 
@@ -309,8 +330,6 @@
 # 2) Move the call to apply() from the main loop to the END statement.
 # 3) In the main loop consider adding code that deletes partial JPATHS[]
 #    elements that would result from parsing invalid JSON files.
-# Compatibility Note:
-# 1) Very old gawk versions: replace 'delete JPATHS' with 'split("", JPATHS)'.
 
 	TOKEN=""; delete TOKENS; NTOKENS=ITOKENS=0
 	delete JPATHS; NJPATHS=0
